# MMM

## Module
On a un module écrit en CPython.

On peut l'importer dans python directement.

```python
import Module

dir(Module)
>> ['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'check', 'welcome']


Module.welcome("test")
>> "Welcome to the Matrix"
Module.check("AAA")
>> Incorrect.
```

Il va falloir reverse le module afin de récupérer le flag !
Voilà le code de cette fonction:

```C
  srand(0x1337u);
  if ( (unsigned int)PyArg_ParseTuple(a2, "s", &s) )
  {
    v4 = strlen(s);
    for ( i = 0LL; i < v4; ++i )
    {
      if ( ((rand() % 256) ^ s[i]) != key[i] )
      {
        v5 = Py_BuildValue("s", "Incorrect.");
        goto LABEL_9;
      }
    }
    v5 = Py_BuildValue("s", "Correct.");
  }
  else
  {
    v5 = 0LL;
  }
```

C'est un pattern assez simple, on voit un appel à ``srand`` qui va affecter une seed à la fonction rand().
Puis des appel à rand() et un xor sur notre input. On peut donc écrire un petit script en C afin de prédire ces valeurs.


```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
  srand(0x1337);
  for(int i = 0; i<10; i++)
    printf("%p, ", rand() % 256);
  return 0;
}
```

Il suffit ensuite de xorer avec la clef et on retrouve l'input souhaité:

```BZHCTF{S33!```

On voit clairement qu'il nous manque une partie du flag. Cependant il n'y a aucune autre fonction dans ce module.

En ouvrant le module dans un désassembleur, on se rend compte qu'il y a en fait plusieurs modules dans ce fichier.
- Module
- Madness
- Maze

## Maze

Passont au module maze. Pour l'importer il faut renommer le fichier en "Maze.so" puis l'importer.

On se rend compte qu'on a quelques mouvements possibles.

```python
import Maze

dir(Maze)
['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'check_solved', 'move_down', 'move_left', 'move_right', 'move_up']
```

On voit donc qu'il y a des chances que l'ont soit dans un Maze. On peut assez facilement extraire le labyrinthe depuis l'exécutable.

Voilà à quoi ressemble le labyrinthe.
```
  0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
  0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00,
  0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00,
  0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
  0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00
```

On peut le résoudre assez simplement à la main.

Une fois résolu, on obtiens un condensat de nos mouvements.

```bash
$ python3 solve.py
Solved. Here is your reward: 6abf0cd1ac959be725c67df3479cd2cd
```

On se demande alors à quoi va servir ce condensat.

## Madness

On peut maintenant passer à la 3ème et dernier étape de ce crackme.

```python
>>> import Madness
>>> dir(Madness)
['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'get_flag']
```

On voit qu'il y a uniquement une fonction get_flag. On peut alors tenter notre clef en input en bytes:


```python
import Madness
Madness.get_flag(bytes.fromhex("6abf0cd1ac959be725c67df3479cd2cd"))
> Good job! Append this to your flag! _CPyth0n_M0dul3s_4r3_fuN_aR3nt_theY?}
```

On obtient donc le flag:

BZHCTF{S33!_CPyth0n_M0dul3s_4r3_fuN_aR3nt_theY?}

