#!/usr/bin/env python3
# pylint: disable=missing-function-docstring,missing-module-docstring,missing-class-docstring
# sudo docker-compose up --build
import json
import math
import random
import sys
from secrets import token_hex

FLAG = "REDACTED"

PROMPT = ">>> "

LIST_PHI = []
LIST_TETA = []

LIST_PHI.append(0)
for x in range(1,16):
    LIST_PHI.append(2 * math.pi * ((14+x)/40))


LIST_TETA.append(0)
for x in range(1,15):
    LIST_TETA.append(math.pi * ((14+x)/40))
LIST_TETA.append(math.pi)


MULT_BY_1 = list(range(256))

MULT_BY_2 = [
0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
]

MULT_BY_3 = [
0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a
]

RBOX = [
[0x63, 0x7c, 0x4d, 0x57, 0x74, 0xb1, 0x79, 0xca, 0x49, 0x04, 0xab, 0xfc, 0x6e, 0xef, 0xb7, 0x2d],
[0xd7, 0x59, 0xd0, 0x39, 0xa6, 0x77, 0xac, 0x26, 0x44, 0x50, 0x25, 0x7f, 0x09, 0x16, 0xe5, 0x4c],
[0x98, 0xb8, 0xdf, 0xcd, 0xba, 0xb4, 0x4e, 0x8e, 0x81, 0xbb, 0xc8, 0x8d, 0x84, 0x56, 0x60, 0x54],
[0xf0, 0xe7, 0x5b, 0x75, 0xe1, 0x55, 0xcc, 0x03, 0xf7, 0x61, 0xd9, 0x32, 0x20, 0x72, 0xf4, 0x6f],
[0x9e, 0x67, 0x2f, 0x73, 0x9c, 0xa0, 0x95, 0x93, 0x2e, 0xb2, 0x88, 0xa3, 0xf5, 0x6d, 0x34, 0xe9],
[0x12, 0xfe, 0xae, 0x1f, 0xb6, 0xaf, 0xb5, 0x8b, 0x31, 0x43, 0xf9, 0x8a, 0xe2, 0xed, 0xf8, 0x71],
[0x0b, 0x22, 0x21, 0xd5, 0xde, 0x38, 0xc9, 0x07, 0x83, 0xc7, 0x78, 0xa4, 0x15, 0x41, 0xf2, 0xd1],
[0x29, 0xb0, 0x62, 0xbc, 0x3e, 0x66, 0xcb, 0x70, 0xc2, 0x91, 0xeb, 0xd4, 0xa8, 0xc6, 0xc4, 0xda],
[0x3c, 0x35, 0xc0, 0xa1, 0xe4, 0x82, 0x6b, 0x00, 0x3d, 0x47, 0x23, 0xf3, 0xb9, 0xf1, 0x1b, 0x9b],
[0x64, 0x06, 0x2a, 0xec, 0x96, 0xe8, 0xa2, 0x0e, 0x28, 0x53, 0xc5, 0x0c, 0x69, 0x45, 0x87, 0x9f],
[0x7a, 0xff, 0xad, 0x5c, 0x85, 0x30, 0x5d, 0x48, 0x89, 0x7e, 0x05, 0x18, 0x08, 0xaa, 0x17, 0x94],
[0x4a, 0x0d, 0xd2, 0xbe, 0x8f, 0xfb, 0x97, 0x7d, 0x02, 0x7b, 0x24, 0xc1, 0x0f, 0xe0, 0x6a, 0x4f],
[0xf6, 0x1e, 0xc3, 0x5e, 0x42, 0x52, 0x99, 0x5a, 0x1c, 0x33, 0xce, 0xfd, 0x36, 0xa9, 0x51, 0xdd],
[0x13, 0xdb, 0x90, 0x9d, 0xee, 0x68, 0x80, 0xa7, 0x58, 0x14, 0xd3, 0x2c, 0x0a, 0xdc, 0x3a, 0x4b],
[0x46, 0x92, 0x2b, 0x01, 0xe3, 0xa5, 0x8c, 0xe6, 0x6c, 0x9a, 0x40, 0xbd, 0x37, 0xfa, 0xea, 0x3f],
[0xb3, 0xcf, 0x1a, 0xd6, 0x86, 0x76, 0x19, 0x1d, 0x27, 0x3b, 0x10, 0x65, 0x11, 0x5f, 0xbf, 0xd8]]



def xor_bloch_sphere(b1, b2):
    phi1 = LIST_PHI.index(b1.get_phi())
    phi2 = LIST_PHI.index(b2.get_phi())

    teta1 = LIST_TETA.index(b1.get_teta())
    teta2 = LIST_TETA.index(b2.get_teta())

    new_phi = phi1 ^ phi2
    new_teta = teta1 ^ teta2

    return BlochSphere(LIST_PHI[new_phi], LIST_TETA[new_teta])


def int_to_bloch_sphere(val):
    phi = LIST_PHI[val // 16]
    teta = LIST_TETA[val % 16]

    return BlochSphere(phi, teta)


class BlochSphere:
    def __init__(self, phi, teta):
        self.phi = phi
        self.teta = teta

    def get_phi(self):
        return self.phi

    def get_teta(self):
        return self.teta

    def get_int(self):
        return LIST_PHI.index(self.get_phi()) * 16 + LIST_TETA.index(self.get_teta())

    def replace(self):
        index_phi = LIST_PHI.index(self.phi)
        index_teta = LIST_TETA.index(self.teta)

        newindex_phi = RBOX[index_phi][index_teta] // 16
        newindex_teta = RBOX[index_phi][index_teta] % 16

        self.phi = LIST_PHI[newindex_phi]
        self.teta = LIST_TETA[newindex_teta]

    def pauli_x(self, number):
        self.teta = LIST_TETA[ ( LIST_TETA.index(self.get_teta())+number )%len(LIST_TETA) ]

    def pauli_z(self, number):
        self.phi = LIST_PHI[ ( LIST_PHI.index(self.get_phi())+number )%len(LIST_PHI) ]

    def measure_z(self):
        projection_z_axis= math.cos(self.get_teta())
        val = random.SystemRandom().uniform(-1, 1)

        if val < projection_z_axis:
            return 0
        else:
            return 1

    def measure_x(self):
        projection_x_axis= math.cos(self.get_phi())
        val = random.SystemRandom().uniform(-1, 1)

        if val < projection_x_axis:
            return 0
        else:
            return 1

    def __str__(self):
        return f"Phi : {self.phi}, Teta : {self.teta}"


class CipherBlock:
    BLOCK_SIZE = 16
    NB_ROUND = 6

    def __init__(self, block_user, key_chall):
        self.block = []

        for i in block_user:
            self.block.append(int_to_bloch_sphere(i))
        self.key = []

        for y in key_chall:
            self.key.append(int_to_bloch_sphere(y))

    def get_block(self):
        return self.block

    def shuffle(self):
        new_block = []
        new_mapping = [0, 0xd, 0xa, 7, 4, 1, 0xe, 0xb, 8, 5, 2, 0xf, 0xc, 9, 6, 3]

        for i in new_mapping:
            new_block.append(self.block[i])

        self.block = new_block

    def replace(self):
        for b in self.block:
            b.replace()

    def add_key(self, key):
        new_block = []

        for i in range(CipherBlock.BLOCK_SIZE):
            new_block.append(xor_bloch_sphere(self.block[i], key[i]))

        self.block = new_block

    def pauli_x(self, index):
        for b in self.block:
            b.pauli_x(index)

    def pauli_z(self, index):
        for b in self.block:
            b.pauli_z(index)

    def mix_block(self):
        for i in range(0, 16, 4):
            q1, q2, q3, q4 = self.block[i+0], self.block[i+1], self.block[i+2], self.block[i+3]
            iq1, iq2, iq3, iq4 = q1.get_int(), q2.get_int(), q3.get_int(), q4.get_int()

            nq1 = MULT_BY_2[iq1] ^ MULT_BY_3[iq2] ^ \
                  MULT_BY_1[iq3] ^ MULT_BY_1[iq4]
            nq2 = MULT_BY_1[iq1] ^ MULT_BY_2[iq2] ^ \
                  MULT_BY_3[iq3] ^ MULT_BY_1[iq4]
            nq3 = MULT_BY_1[iq1] ^ MULT_BY_1[iq2] ^ \
                  MULT_BY_2[iq3] ^ MULT_BY_3[iq4]
            nq4 = MULT_BY_3[iq1] ^ MULT_BY_1[iq2] ^ \
                  MULT_BY_1[iq3] ^ MULT_BY_2[iq4]

            self.block[i+0] = int_to_bloch_sphere(nq1)
            self.block[i+1] = int_to_bloch_sphere(nq2)
            self.block[i+2] = int_to_bloch_sphere(nq3)
            self.block[i+3] = int_to_bloch_sphere(nq4)

    def prepare_message(self):
        for y in range(CipherBlock.NB_ROUND):
            self.replace()

            if y%2==1:
                self.shuffle()
                self.mix_block()
            else:
                self.pauli_x(y)
                self.pauli_z(y)

            self.add_key(self.key)

    def measure(self, index, index_phi_user, index_teta_user):
        b_to_xor = BlochSphere(LIST_PHI[index_phi_user], LIST_TETA[index_teta_user])
        btmp = xor_bloch_sphere(b_to_xor, self.block[index])
        self.block[index] = btmp

        self.shuffle()
        self.pauli_x(index)
        self.pauli_z(index)

        self.add_key(self.key)
        res = []

        for i in range(CipherBlock.BLOCK_SIZE):
            generated_bits = 0
            for y in range(16):
                generated_bits |= (1 & self.block[i].measure_z()) << y
            for y in range(16, 16*2):
                generated_bits |= (1 & self.block[i].measure_x()) << y
            res.append(generated_bits)

        return res

def check_data_user(data):
    for c in data:
        if not c.upper() in "0123456789ABCDEF":
            print("Received a message that is not a hex string.")
            sys.exit(1)

    tmp_data = bytearray.fromhex(data)
    if not len(tmp_data) == 16:
        print("Received a message with invalid size.")
        sys.exit(1)

    return tmp_data

def main():
    print("Welcome to my new ultra secure cipher.")
    print("If you manage to get my key, I will give you a reward.")

    key = bytearray.fromhex(token_hex(16))

    index_key = 0
    list_seen_message = []
    list_current_message = []

    while True:
        print(PROMPT, end='')
        try:
            user_message = json.loads(input())
        except json.JSONDecodeError:
            print("Error when parsing json.")
            sys.exit(1)

        if user_message.get("TYPE") == "inputMessage":
            data_user= user_message.get("DATA")
            data_user = check_data_user(data_user)
            if data_user in list_seen_message:
                print("This message has already been seen.")
                sys.exit(1)
            else:
                list_seen_message.append(data_user)

            cipher = CipherBlock(data_user,key)
            cipher.prepare_message()
            list_current_message.append(cipher)
            print("Your message has been stored.")

        elif user_message.get("TYPE") == "input_multiple_messages":
            data_user= user_message.get("MESSAGES")

            for message in data_user:
                clean_message = check_data_user(message)
                if clean_message in list_seen_message:
                    print("This message has already been seen.")
                    sys.exit(1)
                else:
                    list_seen_message.append(clean_message)

                cipher = CipherBlock(clean_message, key)
                cipher.prepare_message()
                list_current_message.append(cipher)

            print("Multiple messages has been stored.")

        elif user_message.get("TYPE") == "combine_message":
            if len(list_current_message) < 2:
                print("Nothing to do.")
            else:
                tmp_message = list_current_message[0]
                for i in range(1,len(list_current_message)):
                    tmp = []
                    for y in range(CipherBlock.BLOCK_SIZE):
                        val = xor_bloch_sphere(tmp_message.get_block()[y],
                                               list_current_message[i].get_block()[y])
                        tmp.append(val)
                    tmp_message.block = tmp

                list_current_message = [tmp_message]
                print("Messages combined.")

        elif user_message.get("TYPE") == "measure_message":
            index_phi_user = user_message.get("PHI")
            index_teta_user = user_message.get("TETA")
            index = user_message.get("INDEX")

            result = list_current_message[0].measure(index,index_phi_user,index_teta_user)
            print(f"The result of the measure is : {result}.")
            list_current_message = []

        elif user_message.get("TYPE") == "guess_key":
            guess_user_key = user_message.get("USERKEY")

            if guess_user_key == hex(key[index_key]).replace("0x",'').zfill(2):
                print("The byte is valid.")
                list_seen_message = []
                index_key+=1
                if index_key == 16:
                    print(f"Here is your flag : {FLAG}.")
            else:
                print("Sorry, wrong key.")
                sys.exit(1)

        else:
            print("Unknow type.")
            sys.exit(1)

if __name__ == "__main__":
    main()
